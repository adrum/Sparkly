default_platform(:mac)

# Configuration via environment variables
#
# App Configuration:
#   APP_NAME          - App name (e.g., "Sparkley")
#   XCODEPROJ         - Xcode project file (e.g., "Sparkley.xcodeproj")
#   SCHEME            - Build scheme (e.g., "Sparkley")
#   TARGET            - Build target (defaults to APP_NAME)
#   GITHUB_REPOSITORY - GitHub repo (e.g., "adrum/Sparkley")
#   MACOS_MIN_VERSION - Minimum macOS version for release notes (default: "14.0")
#
# GitHub (required for releases):
#   GITHUB_TOKEN      - GitHub Personal Access Token
#
# Notarization via App Store Connect API Key (recommended):
#   ASC_API_KEY_PATH  - Path to api_key.json file (default: fastlane/api_key.json)
#
# Code Signing:
#   DEVELOPER_ID_APPLICATION - Signing identity (e.g., "Developer ID Application: Name (TEAMID)")

def app_name
  ENV["APP_NAME"] || "Sparkley"
end

def xcodeproj
  ENV["XCODEPROJ"] || "#{app_name}.xcodeproj"
end

def scheme
  ENV["SCHEME"] || app_name
end

def target
  ENV["TARGET"] || app_name
end

def github_repository
  ENV["GITHUB_REPOSITORY"] || "adrum/#{app_name}"
end

def macos_min_version
  ENV["MACOS_MIN_VERSION"] || "14.0"
end

def asc_api_key_path
  ENV["ASC_API_KEY_PATH"] || "fastlane/api_key.json"
end

def load_asc_api_key
  key_path = asc_api_key_path

  unless File.exist?(key_path)
    UI.user_error!("App Store Connect API key not found at #{key_path}\n" \
                   "Create one at https://appstoreconnect.apple.com/access/integrations/api\n" \
                   "Then save as api_key.json with format:\n" \
                   "{\n" \
                   "  \"key_id\": \"YOUR_KEY_ID\",\n" \
                   "  \"issuer_id\": \"YOUR_ISSUER_ID\",\n" \
                   "  \"key\": \"-----BEGIN PRIVATE KEY-----\\n...\\n-----END PRIVATE KEY-----\"\n" \
                   "}")
  end

  app_store_connect_api_key(
    key_filepath: key_path
  )
end

platform :mac do
  desc "Build and sign the macOS app with Developer ID"
  lane :build_signed do
    ensure_env_vars(
      env_vars: ["DEVELOPER_ID_APPLICATION"]
    )

    sh("rm -rf ../build")

    build_mac_app(
      scheme: scheme,
      project: xcodeproj,
      output_directory: "./build",
      output_name: "#{app_name}.app",
      export_method: "developer-id",
      skip_package_pkg: true,
      clean: true,
      configuration: "Release",
      codesigning_identity: ENV["DEVELOPER_ID_APPLICATION"]
    )
  end

  desc "Build without signing (for testing)"
  lane :build_unsigned do
    sh("rm -rf ../build")

    xcodebuild(
      scheme: scheme,
      project: xcodeproj,
      configuration: "Release",
      derivedDataPath: "./build/DerivedData",
      xcargs: "CODE_SIGN_IDENTITY='' CODE_SIGNING_REQUIRED=NO CODE_SIGNING_ALLOWED=NO -destination 'generic/platform=macOS'"
    )

    sh("mkdir -p ../build")
    sh("cp -R '../build/DerivedData/Build/Products/Release/#{app_name}.app' ../build/")
  end

  desc "Notarize the app with Apple using App Store Connect API"
  lane :notarize_app do
    api_key = load_asc_api_key
    app_path = "../build/#{app_name}.app"

    UI.message("Submitting for notarization...")

    notarize(
      package: app_path,
      api_key: api_key,
      print_log: true
    )

    UI.success("App notarized and stapled!")
  end

  desc "Build, sign, and notarize the app"
  lane :build_notarized do
    build_signed
    notarize_app
  end

  desc "Create a zip archive of the app"
  lane :archive do |options|
    version = options[:version] || get_version_number(xcodeproj: xcodeproj, target: target)

    zip_name = "#{app_name}-#{version}.zip"
    zip_path = "./build/#{zip_name}"

    sh("cd ../build && zip -r -y '#{zip_name}' '#{app_name}.app'")

    UI.success("Created archive: #{zip_path}")
    zip_path
  end

  desc "Build, archive, and release UNSIGNED to GitHub"
  lane :release do |options|
    ensure_env_vars(
      env_vars: ["GITHUB_TOKEN"]
    )

    version = get_version_number(xcodeproj: xcodeproj, target: target)
    build_number = get_build_number(xcodeproj: xcodeproj)
    tag_name = "v#{version}"
    release_name = "#{app_name} #{version}"

    UI.message("Building version #{version} (#{build_number})")

    build_unsigned
    archive(version: version)

    publish_to_github(
      version: version,
      tag_name: tag_name,
      release_name: release_name,
      is_draft: false,
      is_prerelease: options[:prerelease] || false
    )
  end

  desc "Build, sign, notarize, and release to GitHub"
  lane :release_signed do |options|
    ensure_env_vars(
      env_vars: ["GITHUB_TOKEN", "DEVELOPER_ID_APPLICATION"]
    )

    version = get_version_number(xcodeproj: xcodeproj, target: target)
    build_number = get_build_number(xcodeproj: xcodeproj)
    tag_name = "v#{version}"
    release_name = "#{app_name} #{version}"

    UI.message("Building signed version #{version} (#{build_number})")

    build_notarized
    archive(version: version)

    publish_to_github(
      version: version,
      tag_name: tag_name,
      release_name: release_name,
      is_draft: false,
      is_prerelease: options[:prerelease] || false
    )
  end

  desc "Create a draft release (unsigned)"
  lane :release_draft do
    ensure_env_vars(
      env_vars: ["GITHUB_TOKEN"]
    )

    version = get_version_number(xcodeproj: xcodeproj, target: target)
    tag_name = "v#{version}"
    release_name = "#{app_name} #{version}"

    UI.message("Building version #{version}")

    build_unsigned
    archive(version: version)

    publish_to_github(
      version: version,
      tag_name: tag_name,
      release_name: release_name,
      is_draft: true,
      is_prerelease: false
    )
  end

  desc "Create a signed draft release"
  lane :release_draft_signed do
    ensure_env_vars(
      env_vars: ["GITHUB_TOKEN", "DEVELOPER_ID_APPLICATION"]
    )

    version = get_version_number(xcodeproj: xcodeproj, target: target)
    tag_name = "v#{version}"
    release_name = "#{app_name} #{version}"

    UI.message("Building signed version #{version}")

    build_notarized
    archive(version: version)

    publish_to_github(
      version: version,
      tag_name: tag_name,
      release_name: release_name,
      is_draft: true,
      is_prerelease: false
    )
  end

  desc "Bump version number"
  lane :bump do |options|
    bump_type = options[:type] || "patch"

    increment_version_number(
      xcodeproj: xcodeproj,
      bump_type: bump_type
    )

    increment_build_number(xcodeproj: xcodeproj)

    version = get_version_number(xcodeproj: xcodeproj, target: target)
    build_number = get_build_number(xcodeproj: xcodeproj)

    UI.success("Bumped to version #{version} (#{build_number})")
  end

  # Helper to publish to GitHub
  def publish_to_github(version:, tag_name:, release_name:, is_draft:, is_prerelease:)
    existing_release = get_github_release(
      url: github_repository,
      version: tag_name,
      api_bearer: ENV["GITHUB_TOKEN"]
    ) rescue nil

    if existing_release
      UI.important("Release #{tag_name} already exists. Updating...")

      upload_url = existing_release["upload_url"].gsub("{?name,label}", "")

      sh("curl -X POST " \
         "-H 'Authorization: Bearer #{ENV["GITHUB_TOKEN"]}' " \
         "-H 'Content-Type: application/zip' " \
         "--data-binary '@../build/#{app_name}-#{version}.zip' " \
         "'#{upload_url}?name=#{app_name}-#{version}.zip'")
    else
      set_github_release(
        repository_name: github_repository,
        api_bearer: ENV["GITHUB_TOKEN"],
        name: release_name,
        tag_name: tag_name,
        description: release_notes(version: version),
        commitish: "main",
        upload_assets: ["build/#{app_name}-#{version}.zip"],
        is_draft: is_draft,
        is_prerelease: is_prerelease
      )
    end

    UI.success("Released #{release_name} to GitHub!")
  end

  # Helper to generate release notes
  def release_notes(version:)
    changelog = File.read("../CHANGELOG.md") rescue nil

    if changelog
      version_section = changelog[/## \[?#{Regexp.escape(version)}\]?.*?\n(.*?)(?=\n## |\z)/m, 1]
      return version_section.strip if version_section && !version_section.strip.empty?
    end

    <<~NOTES
      ## #{app_name} #{version}

      ### Installation

      1. Download `#{app_name}-#{version}.zip`
      2. Unzip and drag `#{app_name}.app` to your Applications folder

      ### Requirements

      - macOS #{macos_min_version} or later
    NOTES
  end
end
