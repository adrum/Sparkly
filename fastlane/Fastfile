default_platform(:mac)

# Configuration via environment variables
#
# App Configuration (required):
#   APP_NAME                   - App name (e.g., "MyApp")
#   XCODEPROJ                  - Xcode project file (e.g., "MyApp.xcodeproj")
#   SCHEME                     - Build scheme (e.g., "MyApp")
#   TARGET                     - Build target (e.g., "MyApp")
#   GITHUB_REPOSITORY          - GitHub repo (e.g., "username/repo")
#   DEVELOPER_ID_APPLICATION   - Signing identity (e.g., "Developer ID Application: Name (TEAMID)")
#
# Optional:
#   MACOS_MIN_VERSION          - Minimum macOS version for release notes (default: "14.0")
#   ASC_API_KEY_PATH           - Path to api_key.json file (default: "api_key.json")
#
# GitHub (required for releases):
#   GITHUB_TOKEN               - GitHub Personal Access Token
#
# Match (required for signed builds):
#   MATCH_GIT_URL              - Git repo for certificates
#   MATCH_PASSWORD             - Password to decrypt certificates

def app_name
  ENV.fetch("APP_NAME")
end

def xcodeproj
  ENV.fetch("XCODEPROJ")
end

def scheme
  ENV.fetch("SCHEME")
end

def target
  ENV.fetch("TARGET")
end

def github_repository
  ENV.fetch("GITHUB_REPOSITORY")
end

def developer_id_identity
  ENV["DEVELOPER_ID_APPLICATION"]
end

def macos_min_version
  ENV["MACOS_MIN_VERSION"] || "14.0"
end

def asc_api_key_path
  ENV["ASC_API_KEY_PATH"] || "api_key.json"
end

def load_asc_api_key
  key_path = asc_api_key_path

  unless File.exist?(key_path)
    UI.user_error!("App Store Connect API key not found at #{key_path}\n" \
                   "Create one at https://appstoreconnect.apple.com/access/integrations/api\n" \
                   "Then save as api_key.json with format:\n" \
                   "{\n" \
                   "  \"key_id\": \"YOUR_KEY_ID\",\n" \
                   "  \"issuer_id\": \"YOUR_ISSUER_ID\",\n" \
                   "  \"key\": \"-----BEGIN PRIVATE KEY-----\\n...\\n-----END PRIVATE KEY-----\"\n" \
                   "}")
  end

  # Load JSON and pass individual parameters
  key_json = JSON.parse(File.read(key_path))

  app_store_connect_api_key(
    key_id: key_json["key_id"],
    issuer_id: key_json["issuer_id"],
    key_content: key_json["key"]
  )
end

platform :mac do
  desc "Build and sign the macOS app with Developer ID"
  lane :build_signed do
    sh("rm -rf ../build")

    # Sync cert from match
    match

    identity = developer_id_identity
    UI.message("Signing with: #{identity}")

    # Build without signing first
    xcodebuild(
      scheme: scheme,
      project: xcodeproj,
      configuration: "Release",
      derivedDataPath: "./build/DerivedData",
      xcargs: "CODE_SIGN_IDENTITY='' CODE_SIGNING_REQUIRED=NO CODE_SIGNING_ALLOWED=NO -destination 'generic/platform=macOS'"
    )

    # Copy the app to build directory
    sh("mkdir -p ../build")
    sh("cp -R '../build/DerivedData/Build/Products/Release/#{app_name}.app' ../build/")

    # Sign all nested code recursively, then the app bundle
    UI.message("Signing app with Developer ID: #{identity}")
    app_path = "../build/#{app_name}.app"

    # Sign standalone executables inside frameworks (not bundles)
    sh("find '#{app_path}' -type f -perm +111 -path '*/Frameworks/*.framework/*' ! -name '.*' -exec codesign --force --timestamp --options runtime --sign '#{identity}' {} \\;")

    # Sign all bundles (frameworks, apps, xpc) from deepest to shallowest
    sh("find '#{app_path}' -depth -type d \\( -name '*.framework' -o -name '*.app' -o -name '*.xpc' \\) -exec codesign --force --timestamp --options runtime --sign '#{identity}' {} \\;")

    UI.success("App signed with Developer ID")
  end

  desc "Build without signing (for testing)"
  lane :build_unsigned do
    sh("rm -rf ../build")

    xcodebuild(
      scheme: scheme,
      project: xcodeproj,
      configuration: "Release",
      derivedDataPath: "./build/DerivedData",
      xcargs: "CODE_SIGN_IDENTITY='' CODE_SIGNING_REQUIRED=NO CODE_SIGNING_ALLOWED=NO -destination 'generic/platform=macOS'"
    )

    sh("mkdir -p ../build")
    sh("cp -R '../build/DerivedData/Build/Products/Release/#{app_name}.app' ../build/")
  end

  desc "Notarize the app with Apple using App Store Connect API"
  lane :notarize_app do
    api_key = load_asc_api_key
    app_path = "build/#{app_name}.app"

    UI.message("Submitting for notarization...")

    notarize(
      package: app_path,
      api_key: api_key,
      print_log: true
    )

    UI.success("App notarized and stapled!")
  end

  desc "Build, sign, and notarize the app"
  lane :build_notarized do
    build_signed
    notarize_app
  end

  desc "Create a zip archive of the app"
  lane :archive do |options|
    version = options[:version] || get_version_number(xcodeproj: xcodeproj, target: target)

    zip_name = "#{app_name}-#{version}.zip"
    zip_path = "./build/#{zip_name}"

    sh("cd ../build && zip -r -y '#{zip_name}' '#{app_name}.app'")

    UI.success("Created archive: #{zip_path}")
    zip_path
  end

  desc "Build, archive, and release UNSIGNED to GitHub"
  lane :release do |options|
    ensure_env_vars(
      env_vars: ["GITHUB_TOKEN"]
    )

    version = get_version_number(xcodeproj: xcodeproj, target: target)
    build_number = get_build_number(xcodeproj: xcodeproj)
    tag_name = "v#{version}"
    release_name = "#{app_name} #{version}"

    UI.message("Building version #{version} (#{build_number})")

    build_unsigned
    archive(version: version)

    publish_to_github(
      version: version,
      tag_name: tag_name,
      release_name: release_name,
      is_draft: false,
      is_prerelease: options[:prerelease] || false
    )
  end

  desc "Build, sign, notarize, and release to GitHub"
  lane :release_signed do |options|
    ensure_env_vars(
      env_vars: ["GITHUB_TOKEN"]
    )

    version = get_version_number(xcodeproj: xcodeproj, target: target)
    build_number = get_build_number(xcodeproj: xcodeproj)
    tag_name = "v#{version}"
    release_name = "#{app_name} #{version}"

    UI.message("Building signed version #{version} (#{build_number})")

    build_notarized
    archive(version: version)

    publish_to_github(
      version: version,
      tag_name: tag_name,
      release_name: release_name,
      is_draft: false,
      is_prerelease: options[:prerelease] || false
    )
  end

  desc "Create a draft release (unsigned)"
  lane :release_draft do
    ensure_env_vars(
      env_vars: ["GITHUB_TOKEN"]
    )

    version = get_version_number(xcodeproj: xcodeproj, target: target)
    tag_name = "v#{version}"
    release_name = "#{app_name} #{version}"

    UI.message("Building version #{version}")

    build_unsigned
    archive(version: version)

    publish_to_github(
      version: version,
      tag_name: tag_name,
      release_name: release_name,
      is_draft: true,
      is_prerelease: false
    )
  end

  desc "Create a signed draft release"
  lane :release_draft_signed do
    ensure_env_vars(
      env_vars: ["GITHUB_TOKEN"]
    )

    version = get_version_number(xcodeproj: xcodeproj, target: target)
    tag_name = "v#{version}"
    release_name = "#{app_name} #{version}"

    UI.message("Building signed version #{version}")

    build_notarized
    archive(version: version)

    publish_to_github(
      version: version,
      tag_name: tag_name,
      release_name: release_name,
      is_draft: true,
      is_prerelease: false
    )
  end

  desc "Bump version number"
  lane :bump do |options|
    bump_type = options[:type] || "patch"

    increment_version_number(
      xcodeproj: xcodeproj,
      bump_type: bump_type
    )

    increment_build_number(xcodeproj: xcodeproj)

    version = get_version_number(xcodeproj: xcodeproj, target: target)
    build_number = get_build_number(xcodeproj: xcodeproj)

    UI.success("Bumped to version #{version} (#{build_number})")
  end

  desc "Generate Sparkle appcast from releases"
  lane :generate_appcast do
    # SPARKLE_PRIVATE_KEY env var is optional - falls back to Keychain

    # Create clean appcast directory (absolute path)
    appcast_dir = File.expand_path("../appcast_artifacts")
    sh("rm -rf '#{appcast_dir}'")
    sh("mkdir -p '#{appcast_dir}'")

    # Download latest release zip from GitHub
    version = get_version_number(xcodeproj: xcodeproj, target: target)
    zip_name = "#{app_name}-#{version}.zip"
    download_url = "https://github.com/#{github_repository}/releases/download/v#{version}/#{zip_name}"

    UI.message("Downloading #{zip_name} from GitHub releases...")
    sh("curl -L -o '#{appcast_dir}/#{zip_name}' '#{download_url}'")

    # Find generate_appcast from Xcode's resolved SPM package
    derived_data = File.expand_path("~/Library/Developer/Xcode/DerivedData")
    sparkle_bin = Dir.glob("#{derived_data}/#{app_name}-*/SourcePackages/artifacts/sparkle/Sparkle/bin/generate_appcast").first

    unless sparkle_bin && File.exist?(sparkle_bin)
      UI.user_error!("generate_appcast not found in DerivedData. Build the project in Xcode first to resolve SPM packages.")
    end

    UI.message("Generating appcast... #{sparkle_bin} #{appcast_dir}")

    # Use key from Keychain (default) or pipe from env var
    if ENV["SPARKLE_PRIVATE_KEY"]
      sh("echo \"$SPARKLE_PRIVATE_KEY\" | '#{sparkle_bin}' --ed-key-file - '#{appcast_dir}'")
    else
      # Fall back to Keychain
      sh("'#{sparkle_bin}' '#{appcast_dir}'")
    end

    # Copy generated appcast to repo root
    sh("cp '#{appcast_dir}/appcast.xml' ../appcast.xml")

    # Cleanup
    sh("rm -rf '#{appcast_dir}'")

    UI.success("Generated appcast.xml")
  end

  # Helper to publish to GitHub
  def publish_to_github(version:, tag_name:, release_name:, is_draft:, is_prerelease:)
    existing_release = get_github_release(
      url: github_repository,
      version: tag_name,
      api_bearer: ENV["GITHUB_TOKEN"]
    ) rescue nil

    if existing_release
      UI.important("Release #{tag_name} already exists. Updating...")

      upload_url = existing_release["upload_url"].gsub("{?name,label}", "")

      sh("curl -X POST " \
         "-H 'Authorization: Bearer #{ENV["GITHUB_TOKEN"]}' " \
         "-H 'Content-Type: application/zip' " \
         "--data-binary '@../build/#{app_name}-#{version}.zip' " \
         "'#{upload_url}?name=#{app_name}-#{version}.zip'")
    else
      set_github_release(
        repository_name: github_repository,
        api_bearer: ENV["GITHUB_TOKEN"],
        name: release_name,
        tag_name: tag_name,
        description: release_notes(version: version),
        commitish: "main",
        upload_assets: ["build/#{app_name}-#{version}.zip"],
        is_draft: is_draft,
        is_prerelease: is_prerelease
      )
    end

    UI.success("Released #{release_name} to GitHub!")
  end

  # Helper to generate release notes
  def release_notes(version:)
    changelog = File.read("../CHANGELOG.md") rescue nil

    if changelog
      version_section = changelog[/## \[?#{Regexp.escape(version)}\]?.*?\n(.*?)(?=\n## |\z)/m, 1]
      return version_section.strip if version_section && !version_section.strip.empty?
    end

    <<~NOTES
      ## #{app_name} #{version}

      ### Installation

      1. Download `#{app_name}-#{version}.zip`
      2. Unzip and drag `#{app_name}.app` to your Applications folder

      ### Requirements

      - macOS #{macos_min_version} or later
    NOTES
  end
end
